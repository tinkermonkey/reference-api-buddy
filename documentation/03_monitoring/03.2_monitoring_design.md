````markdown
# 3.2 Monitoring Interface Design

## Overview

This document details the design for the monitoring interface described in [3.1 Monitoring Interface Requirements](./03.1_monitoring_requirements.md). The interface provides programmatic access to operational metrics and health information for the caching proxy module, intended for use by parent applications.

## 3.2.1 Design Goals

1. Expose operational metrics and health data via a Python class (`MonitoringManager`).
2. Aggregate data from the cache engine, database manager, throttling manager, and core proxy logic.
3. Minimize performance overhead and avoid introducing new dependencies.
4. Provide extensible, testable, and well-documented methods.

## 3.2.2 Class Structure

### 3.2.2.1 MonitoringManager

**Location:** `reference_api_buddy/monitoring/manager.py`

```python
class MonitoringManager:
	def __init__(self, proxy, cache_engine, db_manager, throttle_manager):
		"""Initialize with references to core components."""

	def get_cache_stats(self) -> dict:
		"""Return cache entry counts, sizes, hit/miss rates, TTLs, and evictions."""

	def get_upstream_stats(self) -> dict:
		"""Return upstream response times, error rates, and request volumes."""

	def get_database_stats(self) -> dict:
		"""Return database file path, size, memory usage, and health."""

	def get_proxy_health(self) -> dict:
		"""Return uptime, active threads, and recent errors."""

	def get_throttling_stats(self) -> dict:
		"""Return current throttle state and per-domain request counts."""
```

#### 3.2.2.1.1 Initialization
- The manager is initialized with references to the main proxy, cache engine, database manager, and throttling manager.
- This allows direct access to internal state and statistics.

#### 3.2.2.1.2 Method Details

- **get_cache_stats**: Aggregates cache entry counts (global/per-domain), cache size, hit/miss rates, TTL distribution, and expired/evicted entry counts. Uses cache engine and database manager.
- **get_upstream_stats**: Aggregates upstream response times (avg/min/max/recent), error rates, and request volumes per domain. Uses proxy and possibly metrics collector.
- **get_database_stats**: Reports database file path, on-disk size, in-memory cache size, and connection health. Uses database manager.
- **get_proxy_health**: Reports uptime, active threads/connections, and recent errors. Uses proxy and thread management.
- **get_throttling_stats**: Reports current throttle state and per-domain request counts. Uses throttling manager.

#### 3.2.2.1.3 Extensibility
- Methods return Python dicts for easy serialization.
- Additional methods can be added for custom metrics or historical data.

### 3.2.2.2 Integration Points

- **Cache Engine**: Exposes cache entry counts, sizes, TTLs, hit/miss stats, and evictions.
- **Database Manager**: Exposes file path, size, health, and memory usage.
- **Proxy**: Exposes uptime, thread count, and error logs.
- **Throttling Manager**: Exposes per-domain throttle state and request counts.
- **Metrics Collector (if present)**: Exposes upstream response times, error rates, and request volumes.

## 3.2.3 Data Flow

1. Parent application instantiates `MonitoringManager` with references to core components.
2. Parent calls methods to retrieve metrics as needed.
3. Methods aggregate and return data from the relevant components.

## 3.2.4 Example Usage

```python
from reference_api_buddy.monitoring.manager import MonitoringManager

monitor = MonitoringManager(proxy, cache_engine, db_manager, throttle_manager)
cache_stats = monitor.get_cache_stats()
db_stats = monitor.get_database_stats()
upstream_stats = monitor.get_upstream_stats()
```

## 3.2.5 Error Handling

- All methods should handle missing or unavailable data gracefully (e.g., return `None` or `"unavailable"` for missing stats).
- Exceptions should be logged and not propagated to the parent application unless critical.

## 3.2.6 Performance Considerations

- Methods should avoid expensive operations (e.g., full table scans) and use cached/aggregated stats where possible.
- For large caches, consider sampling or limiting the number of entries analyzed for TTL distribution.

## 3.2.7 Unit Test Coverage

### 3.2.7.1 Test File: `tests/unit_tests/test_monitoring_manager.py`

#### 3.2.7.1.1 Test Cases

- **Test Initialization**: Ensure `MonitoringManager` initializes with all required components.
- **Test get_cache_stats**: Mock cache engine/database manager to return known values; verify correct aggregation and formatting.
- **Test get_upstream_stats**: Mock proxy/metrics collector; verify correct stats for response times, error rates, and volumes.
- **Test get_database_stats**: Mock database manager; verify file path, size, memory usage, and health reporting.
- **Test get_proxy_health**: Mock proxy; verify uptime, thread count, and error reporting.
- **Test get_throttling_stats**: Mock throttling manager; verify throttle state and per-domain request counts.
- **Test Error Handling**: Simulate missing/unavailable data and verify graceful handling.

#### 3.2.7.1.2 Example Test Skeleton

```python
import pytest
from reference_api_buddy.monitoring.manager import MonitoringManager

class DummyComponent:
	# ...implement dummy methods for testing...
	pass

def test_monitoring_manager_initialization():
	monitor = MonitoringManager(DummyComponent(), DummyComponent(), DummyComponent(), DummyComponent())
	assert monitor is not None

def test_get_cache_stats_returns_expected_keys():
	cache_engine = DummyComponent()
	db_manager = DummyComponent()
	# ...set up dummy return values...
	monitor = MonitoringManager(None, cache_engine, db_manager, None)
	stats = monitor.get_cache_stats()
	assert 'total_entries' in stats
	assert 'cache_size_bytes' in stats

# ...additional tests for each method and error handling...
```

## 3.2.8 Future Extensions

- Support for historical metrics and time-windowed queries.
- Optional integration with external monitoring systems (e.g., Prometheus) via adapters.
- Custom metric registration by parent applications.

````
