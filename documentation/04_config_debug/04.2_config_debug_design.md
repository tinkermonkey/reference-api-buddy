# 4.2 Config Debug Design

## Overview

This document outlines the design for implementing administrative endpoints to expose configuration and system state for debugging purposes. The implementation extends the existing `ProxyHTTPRequestHandler` with new admin routes while maintaining security and performance standards.

## Design Goals

1. **Non-intrusive Integration**: Add admin endpoints without disrupting existing proxy functionality
2. **Security-First**: Respect existing security model with secure key validation
3. **Performance**: Minimal overhead for regular proxy requests
4. **Comprehensive Coverage**: Provide detailed insights into configuration, cache, throttling, and system state
5. **Consistent API**: Follow established JSON response patterns and HTTP status codes
6. **Rate Protection**: Prevent abuse through rate limiting

## Architecture Overview

### 1. Request Flow Integration

```
Incoming Request
    ↓
Security Validation (existing)
    ↓
Admin Route Check (NEW)
    ↓ (if admin route)
    Admin Handler (NEW)
    ↓ (if not admin route)
    Existing Proxy Logic
```

### 2. Component Architecture

```
ProxyHTTPRequestHandler
    ├── _handle_request() [MODIFIED]
    ├── _handle_admin_request() [NEW]
    ├── AdminEndpointManager [NEW]
    │   ├── ConfigEndpoint
    │   ├── StatusEndpoint
    │   ├── CacheEndpoint
    │   ├── DomainsEndpoint
    │   └── ValidationEndpoint
    └── AdminSecurityManager [NEW]
```

## Detailed Design

### 1. Request Handler Integration

#### 1.1 Modified `_handle_request` Method

**File**: `reference_api_buddy/core/handler.py`

```python
def _handle_request(self, method: str):
    try:
        # Existing security validation
        if hasattr(self.proxy, "security_manager") and self.proxy.security_manager is not None:
            key, sanitized_path = self.proxy.security_manager.extract_secure_key(
                self.path, self.headers, parse_qs(urlparse(self.path).query)
            )
            if self.proxy.config.get("security", {}).get("require_secure_key", False):
                if not key or not self.proxy.security_manager.validate_request(key):
                    self.logger.warning("Unauthorized request: Invalid or missing secure key.")
                    self.send_response(401)
                    self.end_headers()
                    self.wfile.write(b"Unauthorized: Invalid or missing secure key\n")
                    return
        else:
            sanitized_path = self.path

        # NEW: Admin route detection and handling
        if self._is_admin_path(sanitized_path):
            if not self._is_admin_enabled():
                self.send_response(404)
                self.end_headers()
                self.wfile.write(b"Not Found\n")
                return

            self._handle_admin_request(method, sanitized_path)
            return

        # Existing proxy logic continues...
        # ... rest of existing method unchanged
```

#### 1.2 Admin Route Detection

```python
def _is_admin_path(self, path: str) -> bool:
    """Check if path is an admin endpoint."""
    return path.startswith("/admin/")

def _is_admin_enabled(self) -> bool:
    """Check if admin endpoints are enabled."""
    return self.proxy.config.get("admin", {}).get("enabled", True)
```

### 2. Admin Request Handler

#### 2.1 Main Admin Handler

**File**: `reference_api_buddy/core/handler.py` (continued)

```python
def _handle_admin_request(self, method: str, path: str):
    """Handle admin endpoint requests with rate limiting and routing."""
    try:
        # Rate limiting check
        if not self._check_admin_rate_limit():
            self._send_admin_error(429, "RATE_LIMIT_EXCEEDED", "Too many requests")
            return

        # Log admin access
        self._log_admin_access(method, path)

        # Route to specific admin handler
        if method == "GET":
            self._route_admin_get(path)
        elif method == "POST":
            self._route_admin_post(path)
        else:
            self._send_admin_error(405, "METHOD_NOT_ALLOWED", f"Method {method} not allowed")

    except Exception as e:
        self.logger.error(f"Admin request error: {e}")
        self._send_admin_error(500, "INTERNAL_ERROR", "Internal server error")
```

#### 2.2 Admin Route Dispatcher

```python
def _route_admin_get(self, path: str):
    """Route GET requests to appropriate admin handlers."""
    if path == "/admin/config":
        self._handle_admin_config()
    elif path == "/admin/status":
        self._handle_admin_status()
    elif path == "/admin/domains":
        self._handle_admin_domains()
    elif path == "/admin/cache":
        self._handle_admin_cache()
    elif path.startswith("/admin/cache/"):
        domain = path.split("/", 3)[3]  # Extract domain from /admin/cache/{domain}
        self._handle_admin_cache_domain(domain)
    elif path == "/admin/health":  # Keep existing health endpoint
        self._handle_admin_health()
    else:
        self._send_admin_error(404, "ENDPOINT_NOT_FOUND", f"Admin endpoint not found: {path}")

def _route_admin_post(self, path: str):
    """Route POST requests to appropriate admin handlers."""
    if path == "/admin/validate-config":
        self._handle_admin_validate_config()
    else:
        self._send_admin_error(404, "ENDPOINT_NOT_FOUND", f"Admin endpoint not found: {path}")
```

### 3. Admin Endpoint Implementations

#### 3.1 Configuration Endpoint

```python
def _handle_admin_config(self):
    """Handle GET /admin/config - return sanitized configuration."""
    try:
        config_data = self._get_sanitized_config()
        response = {
            "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
            "proxy_version": "1.0.0",  # Could be dynamic from package metadata
            "security_enabled": self.proxy.config.get("security", {}).get("require_secure_key", False),
            "configuration": config_data["config"],
            "sanitized_fields": config_data["sanitized_fields"]
        }
        self._send_admin_response(200, response)
    except Exception as e:
        self.logger.error(f"Config endpoint error: {e}")
        self._send_admin_error(500, "CONFIG_ERROR", "Failed to retrieve configuration")
```

#### 3.2 Status Endpoint

```python
def _handle_admin_status(self):
    """Handle GET /admin/status - return system health and metrics."""
    try:
        uptime_seconds = int(time.time() - getattr(self.proxy, 'start_time', time.time()))

        components = self._get_component_status()
        metrics = self._get_system_metrics()

        overall_status = self._determine_overall_status(components)

        response = {
            "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
            "status": overall_status,
            "uptime_seconds": uptime_seconds,
            "components": components,
            "metrics": metrics
        }
        self._send_admin_response(200, response)
    except Exception as e:
        self.logger.error(f"Status endpoint error: {e}")
        self._send_admin_error(500, "STATUS_ERROR", "Failed to retrieve status")
```

#### 3.3 Cache Endpoint

```python
def _handle_admin_cache(self):
    """Handle GET /admin/cache - return cache statistics."""
    try:
        cache_stats = self._get_cache_statistics()
        response = {
            "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
            **cache_stats
        }
        self._send_admin_response(200, response)
    except Exception as e:
        self.logger.error(f"Cache endpoint error: {e}")
        self._send_admin_error(500, "CACHE_ERROR", "Failed to retrieve cache statistics")

def _handle_admin_cache_domain(self, domain: str):
    """Handle GET /admin/cache/{domain} - return domain-specific cache data."""
    try:
        domain_stats = self._get_domain_cache_statistics(domain)
        if domain_stats is None:
            self._send_admin_error(404, "DOMAIN_NOT_FOUND", f"Domain not found: {domain}")
            return

        response = {
            "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
            "domain": domain,
            **domain_stats
        }
        self._send_admin_response(200, response)
    except Exception as e:
        self.logger.error(f"Domain cache endpoint error: {e}")
        self._send_admin_error(500, "CACHE_ERROR", f"Failed to retrieve cache data for domain: {domain}")
```

#### 3.4 Domains Endpoint

```python
def _handle_admin_domains(self):
    """Handle GET /admin/domains - return domain mapping status."""
    try:
        domain_stats = self._get_domain_mapping_statistics()
        response = {
            "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
            "domain_mappings": domain_stats
        }
        self._send_admin_response(200, response)
    except Exception as e:
        self.logger.error(f"Domains endpoint error: {e}")
        self._send_admin_error(500, "DOMAINS_ERROR", "Failed to retrieve domain statistics")
```

#### 3.5 Configuration Validation Endpoint

```python
def _handle_admin_validate_config(self):
    """Handle POST /admin/validate-config - validate configuration without applying."""
    try:
        # Read and parse request body
        content_length = int(self.headers.get('Content-Length', 0))
        if content_length == 0:
            self._send_admin_error(400, "EMPTY_BODY", "Request body is required")
            return

        body = self.rfile.read(content_length)
        try:
            request_data = json.loads(body.decode('utf-8'))
        except json.JSONDecodeError:
            self._send_admin_error(400, "INVALID_JSON", "Invalid JSON in request body")
            return

        config_to_validate = request_data.get("configuration", {})

        # Validate configuration
        from reference_api_buddy.core.config import ConfigurationValidator

        merged_config = ConfigurationValidator.merge_with_defaults(config_to_validate)
        is_valid, errors = ConfigurationValidator.validate_config(merged_config)

        # Generate warnings for missing optional fields
        warnings = self._generate_config_warnings(config_to_validate, merged_config)

        response = {
            "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
            "valid": is_valid,
            "errors": errors,
            "warnings": warnings,
            "merged_config": merged_config
        }

        status_code = 200 if is_valid else 400
        self._send_admin_response(status_code, response)

    except Exception as e:
        self.logger.error(f"Config validation endpoint error: {e}")
        self._send_admin_error(500, "VALIDATION_ERROR", "Failed to validate configuration")
```

### 4. Support Methods

#### 4.1 Configuration Sanitization

```python
def _get_sanitized_config(self) -> dict:
    """Return configuration with sensitive data redacted."""
    import copy

    config = copy.deepcopy(self.proxy.config)
    sanitized_fields = []

    def sanitize_dict(d, path=""):
        nonlocal sanitized_fields
        for key, value in d.items():
            current_path = f"{path}.{key}" if path else key

            # Check if field name suggests sensitive data
            if any(sensitive in key.lower() for sensitive in ["key", "secret", "password", "token"]):
                d[key] = "[REDACTED]"
                sanitized_fields.append(current_path)
            elif isinstance(value, dict):
                sanitize_dict(value, current_path)

    sanitize_dict(config)

    return {
        "config": config,
        "sanitized_fields": sanitized_fields
    }
```

#### 4.2 Component Status Checks

```python
def _get_component_status(self) -> dict:
    """Get status of all proxy components."""
    components = {}

    # Cache Engine Status
    try:
        if hasattr(self.proxy, 'cache_engine') and self.proxy.cache_engine:
            cache_stats = self.proxy.cache_engine.get_stats() if hasattr(self.proxy.cache_engine, 'get_stats') else {}
            total_entries = cache_stats.get('cache_size', 0)

            components["cache_engine"] = {
                "status": "healthy",
                "backend": "sqlite" if self.proxy.config.get("cache", {}).get("database_path", ":memory:") != ":memory:" else "memory",
                "total_entries": total_entries,
                "database_size_bytes": self._get_database_size()
            }
        else:
            components["cache_engine"] = {"status": "unavailable"}
    except Exception as e:
        components["cache_engine"] = {"status": "error", "error": str(e)}

    # Database Manager Status
    try:
        if hasattr(self.proxy, 'db_manager') and self.proxy.db_manager:
            components["database_manager"] = {
                "status": "healthy",
                "connection_active": True,
                "last_backup": None  # Could be enhanced with actual backup tracking
            }
        else:
            components["database_manager"] = {"status": "unavailable"}
    except Exception as e:
        components["database_manager"] = {"status": "error", "error": str(e)}

    # Throttle Manager Status
    try:
        if hasattr(self.proxy, 'throttle_manager') and self.proxy.throttle_manager:
            active_throttles = len([s for s in self.proxy.throttle_manager.states.values() if s.delay_seconds > 1])
            components["throttle_manager"] = {
                "status": "healthy",
                "active_throttles": active_throttles
            }
        else:
            components["throttle_manager"] = {"status": "unavailable"}
    except Exception as e:
        components["throttle_manager"] = {"status": "error", "error": str(e)}

    # Security Manager Status
    try:
        if hasattr(self.proxy, 'security_manager') and self.proxy.security_manager:
            components["security_manager"] = {
                "status": "healthy",
                "security_enabled": self.proxy.security_manager.security_enabled
            }
        else:
            components["security_manager"] = {"status": "unavailable"}
    except Exception as e:
        components["security_manager"] = {"status": "error", "error": str(e)}

    return components
```

#### 4.3 System Metrics Collection

```python
def _get_system_metrics(self) -> dict:
    """Collect system-wide metrics."""
    metrics = {}

    try:
        # Use existing monitoring manager if available
        if hasattr(self.proxy, 'monitoring_manager') and self.proxy.monitoring_manager:
            cache_stats = self.proxy.monitoring_manager.get_cache_stats()
            upstream_stats = self.proxy.monitoring_manager.get_upstream_stats()

            metrics["total_requests"] = upstream_stats.get("total_requests", 0)
            metrics["cache_hit_rate"] = cache_stats.get("hit_rate", 0.0)
            metrics["average_response_time_ms"] = upstream_stats.get("average_response_time", 0)
            metrics["errors_last_hour"] = upstream_stats.get("error_count", 0)
        else:
            # Fallback metrics
            metrics = {
                "total_requests": "unavailable",
                "cache_hit_rate": "unavailable",
                "average_response_time_ms": "unavailable",
                "errors_last_hour": "unavailable"
            }
    except Exception as e:
        metrics["error"] = str(e)

    return metrics
```

#### 4.4 Rate Limiting

```python
class AdminRateLimiter:
    """Simple rate limiter for admin endpoints."""

    def __init__(self):
        self.requests = {}  # IP -> list of timestamps
        self.lock = threading.Lock()

    def is_allowed(self, client_ip: str, limit_per_minute: int = 10) -> bool:
        """Check if client is within rate limit."""
        now = time.time()
        minute_ago = now - 60

        with self.lock:
            if client_ip not in self.requests:
                self.requests[client_ip] = []

            # Remove old requests
            self.requests[client_ip] = [t for t in self.requests[client_ip] if t > minute_ago]

            # Check limit
            if len(self.requests[client_ip]) >= limit_per_minute:
                return False

            # Add current request
            self.requests[client_ip].append(now)
            return True

# Add to handler class
def _check_admin_rate_limit(self) -> bool:
    """Check if request is within admin rate limits."""
    if not hasattr(self, '_admin_rate_limiter'):
        self._admin_rate_limiter = AdminRateLimiter()

    client_ip = self.client_address[0]
    limit = self.proxy.config.get("admin", {}).get("rate_limit_per_minute", 10)

    return self._admin_rate_limiter.is_allowed(client_ip, limit)
```

#### 4.5 Response Utilities

```python
def _send_admin_response(self, status_code: int, data: dict):
    """Send standardized JSON response for admin endpoints."""
    import json

    response_data = json.dumps(data, indent=2).encode('utf-8')

    self.send_response(status_code)
    self.send_header('Content-Type', 'application/json')
    self.send_header('Content-Length', str(len(response_data)))
    self.end_headers()
    self.wfile.write(response_data)

def _send_admin_error(self, status_code: int, error_code: str, message: str):
    """Send standardized error response for admin endpoints."""
    error_response = {
        "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
        "success": False,
        "error": message,
        "error_code": error_code
    }
    self._send_admin_response(status_code, error_response)

def _log_admin_access(self, method: str, path: str):
    """Log admin endpoint access for security auditing."""
    if self.proxy.config.get("admin", {}).get("log_access", True):
        client_ip = self.client_address[0]
        self.logger.info(f"Admin access: {client_ip} {method} {path}")
```

### 5. Configuration Integration

#### 5.1 Updated Default Configuration

**File**: `reference_api_buddy/core/config.py`

```python
DEFAULT_CONFIG = {
    # ... existing config sections ...
    "admin": {
        "enabled": True,
        "rate_limit_per_minute": 10,
        "include_sensitive_config": False,
        "log_access": True
    },
    # ... rest of config ...
}
```

#### 5.2 Configuration Validation

```python
# Add to ConfigurationValidator.validate_config()
admin = config.get("admin", {})
if not isinstance(admin.get("enabled", None), bool):
    errors.append("admin.enabled must be a boolean.")
if not isinstance(admin.get("rate_limit_per_minute", None), int):
    errors.append("admin.rate_limit_per_minute must be an integer.")
if not isinstance(admin.get("include_sensitive_config", None), bool):
    errors.append("admin.include_sensitive_config must be a boolean.")
if not isinstance(admin.get("log_access", None), bool):
    errors.append("admin.log_access must be a boolean.")
```

### 6. Security Considerations

#### 6.1 Secure Key Integration

- All admin endpoints respect the existing `security.require_secure_key` setting
- Secure key extraction uses existing `SecurityManager.extract_secure_key()` method
- Rate limiting prevents brute force attacks on admin endpoints
- Access logging provides audit trail

#### 6.2 Data Sanitization

- Configuration responses automatically redact sensitive fields
- Secure keys are never included in any response
- Error messages don't leak sensitive information
- Logging excludes sensitive data

### 7. Performance Considerations

#### 7.1 Minimal Impact on Regular Requests

- Admin route detection is a simple string prefix check
- No additional overhead for non-admin requests
- Component status checks are cached where possible

#### 7.2 Efficient Data Collection

- Leverage existing monitoring manager when available
- Cache statistics are collected from existing mechanisms
- Database queries are optimized for admin endpoint usage

### 8. Testing Strategy

#### 8.1 Unit Tests

**File**: `tests/unit_tests/test_admin_endpoints.py`

```python
class TestAdminEndpoints:
    def test_admin_route_detection(self):
        # Test _is_admin_path method

    def test_config_sanitization(self):
        # Test sensitive data redaction

    def test_rate_limiting(self):
        # Test AdminRateLimiter functionality

    def test_component_status_collection(self):
        # Test _get_component_status method

    def test_response_formatting(self):
        # Test JSON response structure
```

#### 8.2 Integration Tests

**File**: `tests/integration_tests/test_admin_integration.py`

```python
class TestAdminIntegration:
    def test_admin_endpoints_with_security_enabled(self):
        # Test all admin endpoints with secure key

    def test_admin_endpoints_with_security_disabled(self):
        # Test all admin endpoints without security

    def test_admin_rate_limiting_enforcement(self):
        # Test rate limiting with actual HTTP requests

    def test_config_validation_endpoint(self):
        # Test POST /admin/validate-config with various inputs
```

### 9. Documentation and Examples

#### 9.1 API Documentation

Each endpoint should be documented with:
- Purpose and functionality
- Request/response examples
- Error codes and meanings
- Security requirements
- Rate limiting information

#### 9.2 Usage Examples

```python
# Example: Using admin endpoints programmatically
import requests

# Get current configuration (with security)
response = requests.get(f"http://localhost:8080/admin/{secure_key}/config")
config = response.json()

# Validate new configuration
new_config = {"cache": {"default_ttl_seconds": 3600}}
response = requests.post(
    f"http://localhost:8080/admin/{secure_key}/validate-config",
    json={"configuration": new_config}
)
validation_result = response.json()
```

## Implementation Phases

### Phase 1: Core Infrastructure
1. Modify `_handle_request` for admin route detection
2. Implement `_handle_admin_request` and routing
3. Add rate limiting and security validation
4. Implement response utilities

### Phase 2: Basic Endpoints
1. Configuration endpoint with sanitization
2. Status endpoint with component checks
3. Basic cache statistics endpoint

### Phase 3: Advanced Endpoints
1. Domain-specific cache statistics
2. Domain mapping status endpoint
3. Configuration validation endpoint

### Phase 4: Testing and Polish
1. Comprehensive test suite
2. Performance optimization
3. Documentation and examples
4. Security audit

This design provides a comprehensive, secure, and performant solution for administrative debugging endpoints while maintaining the existing proxy functionality and performance characteristics.
