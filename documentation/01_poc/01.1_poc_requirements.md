# Product Requirements Document: Development HTTP-to-HTTPS Caching Proxy Module

## 1. Product Overview

### 1.1 Purpose
A Python module that provides HTTP-to-HTTPS caching proxy functionality with cryptographic access control, designed to be embedded within parent applications for development environments.

### 1.2 Target Users
- Python applications requiring cached API access
- NLP pipeline developers
- Applications needing throttled third-party API integration
- Development tools requiring secure proxy functionality

### 1.3 Key Benefits
- **Embeddable**: Import as Python module, no separate process
- **Secure**: Cryptographic key prevents unauthorized access
- **Self-contained**: All functionality within parent application
- **Minimal external dependencies**: Aside from sqlite, only built-in Python libraries are used

## 2. Module Architecture

### 2.1 Module Interface
**Import and Usage**:
```python
from proxy_module import CachingProxy

# Initialize with configuration
config = {
    "server": {"host": "127.0.0.1", "port": 8080},
    "cache": {"database_path": "cache.db"},
    "domain_mappings": {...},
    "generate_secure_key": True  # Optional security
}

proxy = CachingProxy(config)
secure_key = proxy.get_secure_key()  # Returns None if not enabled
proxy.start()  # Non-blocking start

# Later...
proxy.stop()   # Clean shutdown
```

### 2.2 Secure Key System
**Key Generation**: 32-byte cryptographically secure random key generated at module initialization
**Key Format**: Base64-encoded for URL safety
**Key Lifecycle**: New key generated on each module instantiation

**URL Pattern with Security**:
```
Input:  http://127.0.0.1:18080/{secure_key}/example.com/api/request
Output: https://example.com/api/request

Input without key: http://127.0.0.1:18080/example.com/api/request
Output: 403 Forbidden
```

**Configuration**:
```python
config = {
    "security": {
        "require_secure_key": True,
        "key_position": "path_prefix",  # or "query_param", "header"
        "reject_unsecured": True
    }
}
```

### 2.3 Module Lifecycle Management
**Initialization**:
```python
class CachingProxy:
    def __init__(self, config: dict):
        self.config = config
        self.secure_key = self._generate_secure_key() if config.get('security', {}).get('require_secure_key')
        self.server = None
        self.running = False
        self._setup_database()
        self._setup_metrics()

    def get_secure_key(self) -> str | None:
        """Return secure key if security is enabled, None otherwise"""
        return self.secure_key

    def start(self, blocking=False):
        """Start proxy server in thread or blocking mode"""
        pass

    def stop(self):
        """Clean shutdown with data persistence"""
        pass

    def is_running(self) -> bool:
        """Check if proxy is active"""
        return self.running
```

## 2.4 Module Cache Persistence

### 2.4.1 Database Configuration
**Persistent Storage**: SQLite database for cross-session cache persistence
- **Configuration Option**: `cache.database_path` in module config
- **Default Behavior**: If `database_path` is `None` or `":memory:"`, use in-memory cache
- **Persistent Mode**: If `database_path` is a file path, create/use SQLite database
- **TTL Management**: Configurable default TTL of 7 days per cache entry

**Configuration Schema**:
```python
config = {
    "cache": {
        "database_path": "proxy_cache.db",  # File path for persistence
        # "database_path": None,            # Use in-memory cache
        # "database_path": ":memory:",      # Explicit in-memory cache
        "default_ttl_days": 7,
        "max_entries": 10000,
        "cleanup_interval_hours": 24
    }
}
```

### 2.4.2 Cache Lifecycle Management
**Database Initialization**:
- Create database file and tables if not exists on first use
- Automatic schema migration for version compatibility
- Connection pooling for thread safety
- Automatic cleanup of expired entries on startup

**Cache Entry Expiration**:
- Entries automatically expire after configured TTL
- Background cleanup process removes expired entries
- Manual cache clearing by domain or globally
- Cache statistics include expired entry cleanup counts

**Persistence Guarantees**:
- All cache writes are immediately committed to disk
- Graceful shutdown ensures no data loss
- Database corruption recovery with automatic rebuild
- Cache survives module restarts when using persistent storage

## 2.5 Module Cache Matching

### 2.5.1 HTTP/HTTPS Method-Specific Caching
**GET Request Caching**:
- **Cache Key**: URL only (method + full URL including query parameters)
- **Rationale**: GET requests are idempotent and determined solely by URL
- **Implementation**: `cache_key = hashlib.sha256(f"GET:{normalized_url}".encode()).hexdigest()`

**POST Request Caching**:
- **Cache Key**: URL + request body content
- **Rationale**: POST responses depend on both endpoint and submitted data
- **Implementation**: `cache_key = hashlib.sha256(f"POST:{normalized_url}:{request_body}".encode()).hexdigest()`
- **Body Normalization**: JSON body normalization for consistent cache keys

**Other HTTP Methods**:
- **PUT, DELETE, PATCH, etc.**: No caching, always pass through
- **Rationale**: These methods typically have side effects and shouldn't be cached
- **Behavior**: Forward directly to upstream server without cache lookup or storage

### 2.5.2 Cache Key Generation Strategy
**URL Normalization**:
```python
def normalize_url(self, url: str) -> str:
    """Normalize URL for consistent cache keys"""
    parsed = urlparse(url)
    # Sort query parameters for consistency
    query_params = sorted(parse_qsl(parsed.query))
    normalized_query = urlencode(query_params)

    return urlunparse((
        parsed.scheme.lower(),
        parsed.netloc.lower(),
        parsed.path,
        parsed.params,
        normalized_query,
        ""  # Remove fragment
    ))
```

**Request Body Handling**:
```python
def normalize_request_body(self, body: bytes, content_type: str) -> str:
    """Normalize request body for cache key generation"""
    if not body:
        return ""

    if content_type and "application/json" in content_type:
        try:
            # Parse and re-serialize JSON for consistent formatting
            json_obj = json.loads(body.decode('utf-8'))
            return json.dumps(json_obj, sort_keys=True, separators=(',', ':'))
        except (json.JSONDecodeError, UnicodeDecodeError):
            pass

    # For non-JSON content, use raw body
    return body.hex()
```

### 2.5.3 Cache Matching Logic
**Request Processing Pipeline**:
1. **Method Check**: Determine if request method is cacheable (GET/POST only)
2. **Cache Key Generation**: Create cache key based on method-specific rules
3. **Cache Lookup**: Query database/memory cache for existing entry
4. **TTL Validation**: Check if cached entry is within TTL window
5. **Response Serving**: Serve from cache or forward to upstream

**Cache Miss Handling**:
- Forward non-cacheable methods directly to upstream
- Store successful responses (2xx status codes) in cache
- Do not cache error responses (4xx/5xx status codes)
- Update cache access timestamps for LRU management

**Cache Configuration**:
```python
config = {
    "cache": {
        "cacheable_methods": ["GET", "POST"],  # Configurable method list
        "cache_error_responses": False,        # Don't cache 4xx/5xx
        "min_cache_response_size": 100,       # Skip tiny responses
        "max_cache_response_size": 10485760   # 10MB max cached response
    }
}
```

## 3. Security Requirements

### 3.1 Cryptographic Key Management
**Key Generation**:
```python
import secrets
import base64

def _generate_secure_key(self) -> str:
    """Generate cryptographically secure 32-byte key"""
    key_bytes = secrets.token_bytes(32)
    return base64.urlsafe_b64encode(key_bytes).decode('ascii').rstrip('=')
```

**Key Validation**:
- Constant-time comparison to prevent timing attacks
- Key must be present in every secured request
- Invalid key results in immediate 403 rejection

### 3.2 Secure Request Processing
**URL Processing Pipeline**:
1. Extract potential secure key from URL
2. Validate key using constant-time comparison
3. Strip key from URL before domain transformation
4. Proceed with normal proxy logic

**Request Patterns**:
```python
# Security enabled patterns:
"http://proxy.local/{secure_key}/api.example.com/endpoint"
"http://proxy.local/api/endpoint?key={secure_key}"  # if query_param mode
# Header mode: X-Proxy-Key: {secure_key}

# Without security (if disabled):
"http://proxy.local/api.example.com/endpoint"
```

### 3.3 Admin Endpoint Security
**Secured Management Endpoints**:
```
GET  /admin/{secure_key}/config
POST /admin/{secure_key}/config/reload
GET  /admin/{secure_key}/metrics
DELETE /admin/{secure_key}/cache/{domain}
GET  /admin/{secure_key}/health
POST /admin/{secure_key}/shutdown
```

**Security Validation**:
- All admin endpoints require valid secure key
- Invalid key returns 403 with no information disclosure
- Rate limiting on admin endpoints to prevent brute force

## 4. Enhanced Configuration Schema

### 4.1 Module Configuration Structure
```python
config = {
    "server": {
        "host": "127.0.0.1",
        "port": 8080,
        "max_workers": 10,
        "start_timeout": 5  # seconds to wait for server start
    },
    "security": {
        "require_secure_key": True,
        "key_position": "path_prefix",  # "path_prefix", "query_param", "header"
        "key_param_name": "proxy_key",  # for query_param mode
        "key_header_name": "X-Proxy-Key",  # for header mode
        "admin_rate_limit": 10  # requests per minute
    },
    "cache": {
        "database_path": ":memory:",  # or file path
        "default_ttl_days": 7,
        "max_size_mb": 500,
        "enable_compression": True
    },
    "domain_mappings": {
        "openai": {
            "upstream": "https://api.openai.com",
        }
    },
    "throttling": {
        "default_requests_per_hour": 1000,
        "domain_limits": {},
        "progressive_enabled": True
    },
    "logging": {
        "level": "INFO",
        "include_secure_key": False,  # Never log keys
        "log_to_parent": True  # Use parent app's logger
    }
}
```

### 4.2 Runtime Configuration Access
```python
# Parent application can modify config
proxy.update_config("throttling.default_requests_per_hour", 500)
proxy.get_config("cache.database_path")

# Reload configuration
proxy.reload_config(new_config)
```

## 5. Parent Application Integration

### 5.1 Integration Patterns
**Embedded Mode**:
```python
import my_nlp_library
from proxy_module import CachingProxy

# Setup proxy
proxy_config = {...}
proxy = CachingProxy(proxy_config)
secure_key = proxy.get_secure_key()

# Configure libraries to use proxy URLs with secure key
my_nlp_library.configure_base_url(f'http://127.0.0.1:18080/{secure_key}')

# Start proxy
proxy.start()

try:
    # Run application logic
    result = my_nlp_library.process_text("example")
finally:
    proxy.stop()
```

**Context Manager Support**:
```python
with CachingProxy(config) as proxy:
    secure_key = proxy.get_secure_key()
    # Configure libraries
    # Application logic
    pass  # Automatic cleanup
```

### 5.2 Logging Integration
**Parent Logger Integration**:
```python
import logging

# Proxy uses parent's logger
parent_logger = logging.getLogger('my_app')
config['logging']['parent_logger'] = parent_logger

proxy = CachingProxy(config)
# All proxy logs appear under 'my_app.proxy' namespace
```

### 5.3 Error Handling and Callbacks
**Event Callbacks**:
```python
def on_cache_hit(domain, url, response_time):
    print(f"Cache hit for {domain}: {response_time}ms")

def on_throttle_applied(domain, delay_seconds):
    print(f"Throttling {domain} for {delay_seconds}s")

config['callbacks'] = {
    'on_cache_hit': on_cache_hit,
    'on_throttle_applied': on_throttle_applied,
    'on_error': lambda error: logging.error(f"Proxy error: {error}")
}
```

## 6. Security Implementation Details

### 6.1 Key Extraction Logic
```python
def extract_secure_key(self, request_path: str, headers: dict, query_params: dict) -> tuple[str|None, str]:
    """Extract secure key and return cleaned path"""
    if not self.security_enabled:
        return None, request_path

    key_position = self.config['security']['key_position']

    if key_position == 'path_prefix':
        # Extract from: /key/domain.com/path
        parts = request_path.strip('/').split('/')
        if len(parts) >= 2:
            potential_key = parts[0]
            cleaned_path = '/' + '/'.join(parts[1:])
            return potential_key, cleaned_path

    elif key_position == 'query_param':
        param_name = self.config['security']['key_param_name']
        key = query_params.get(param_name)
        # Remove key from query params
        # Return key and original path

    elif key_position == 'header':
        header_name = self.config['security']['key_header_name']
        key = headers.get(header_name)
        return key, request_path

    return None, request_path
```

### 6.2 Constant-Time Key Validation
```python
import hmac

def validate_secure_key(self, provided_key: str) -> bool:
    """Constant-time key comparison"""
    if not self.secure_key or not provided_key:
        return False

    return hmac.compare_digest(
        self.secure_key.encode('utf-8'),
        provided_key.encode('utf-8')
    )
```

## 7. Module API Reference

### 7.1 Core Methods
```python
class CachingProxy:
    def __init__(self, config: dict)
    def get_secure_key(self) -> str | None
    def start(self, blocking: bool = False) -> None
    def stop(self) -> None
    def is_running(self) -> bool
    def get_metrics(self) -> dict
    def clear_cache(self, domain: str = None) -> int
    def update_config(self, key_path: str, value: any) -> None
    def reload_config(self, new_config: dict) -> None
    def __enter__(self) -> 'CachingProxy'  # Context manager
    def __exit__(self, exc_type, exc_val, exc_tb) -> None
```

### 7.2 Configuration Validation
```python
def validate_config(config: dict) -> tuple[bool, list[str]]:
    """Validate configuration and return errors"""
    errors = []

    # Required fields
    if 'domain_mappings' not in config:
        errors.append("Missing required 'domain_mappings'")

    # Port validation
    port = config.get('server', {}).get('port', 8080)
    if not 1024 <= port <= 65535:
        errors.append(f"Port {port} must be between 1024-65535")

    return len(errors) == 0, errors
```

## 8. Enhanced Security Features

### 8.1 Request Validation Pipeline
1. **Key Extraction**: Extract key from URL/headers/query params
2. **Key Validation**: Constant-time comparison with generated key
3. **Rate Limiting**: Apply rate limits to admin endpoints
4. **Path Sanitization**: Clean and validate transformed URLs
5. **Response Filtering**: Ensure no key leakage in responses/logs

### 8.2 Security Configuration Options
```python
"security": {
    "require_secure_key": True,
    "key_position": "path_prefix",
    "reject_unsecured_admin": True,
    "log_security_events": True,
    "admin_rate_limit_per_minute": 10,
    "failed_auth_lockout_minutes": 5
}
```

This enhanced PRD transforms the standalone proxy into a secure, embeddable Python module with cryptographic access control while maintaining all the original caching and throttling capabilities.
