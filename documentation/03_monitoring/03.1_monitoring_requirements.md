# 3.1 Monitoring Interface Requirements

The monitoring interface provides programmatic access to operational metrics and health information for the caching proxy module. It is intended for use by parent applications (not via CLI or HTTP endpoints) to enable custom dashboards, alerting, or health checks.

## 3.1.1 Purpose

- Enable parent applications to retrieve real-time and historical operational data about the proxy, cache, and upstream API interactions.
- Support observability, troubleshooting, and capacity planning.

## 3.1.2 Scope

- The monitoring interface is a set of Python methods or a manager class (e.g., `MonitoringManager`) that exposes metrics and statistics.
- It interacts with the database manager and other internal components to aggregate and report data.
- No CLI or built-in HTTP endpoints are provided for monitoring; parent applications must call these methods directly.

## 3.1.3 Core Monitoring Capabilities

The monitoring interface MUST provide methods for retrieving the following information:

### 3.1.3.1 Cache Metrics

- **Total cache entries**: Number of cached items, globally and per domain/upstream.
- **Cache size**: Total size of cached data in bytes, both in-memory and on-disk (if persistent).
- **Cache hit/miss statistics**: Number and rate of cache hits and misses, globally and per domain.
- **Cache entry TTLs**: Distribution of remaining TTLs for cached entries (min, max, average).
- **Expired/evicted entries**: Count of expired or evicted cache entries since startup.

### 3.1.3.2 Upstream API Metrics

- **Upstream response times**: Average, min, max, and recent response times per upstream domain.
- **Upstream error rates**: Count and rate of failed upstream requests (4xx/5xx), per domain.
- **Request volume**: Number of requests forwarded to each upstream since startup.

### 3.1.3.3 Database Metrics

- **Database file path**: Absolute path to the SQLite database file (if persistent).
- **Database size on disk**: Current file size in bytes (if persistent).
- **In-memory cache size**: Estimated memory usage of in-memory cache (if used).
- **Database health**: Status of the database connection(s), e.g., open/closed, errors.

### 3.1.3.4 Proxy Health and Uptime

- **Uptime**: Time since proxy/server startup.
- **Active threads/connections**: Number of active worker threads or connections.
- **Recent errors**: List or count of recent errors or exceptions (optionally categorized).

### 3.1.3.5 Throttling and Rate Limiting

- **Current throttle state**: For each domain, current rate limiting status and delay (if any).
- **Requests per domain**: Number of requests per domain in the current rate window.

## 3.1.4 Example Monitoring Interface

The monitoring interface SHOULD be implemented as a class (e.g., `MonitoringManager`) with methods such as:

```python
class MonitoringManager:
    def get_cache_stats(self) -> dict:
        """Return cache entry counts, sizes, hit/miss rates, TTLs, and evictions."""

    def get_upstream_stats(self) -> dict:
        """Return upstream response times, error rates, and request volumes."""

    def get_database_stats(self) -> dict:
        """Return database file path, size, memory usage, and health."""

    def get_proxy_health(self) -> dict:
        """Return uptime, active threads, and recent errors."""

    def get_throttling_stats(self) -> dict:
        """Return current throttle state and per-domain request counts."""
