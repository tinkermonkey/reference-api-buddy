# 2.2 TTL Configuration Design

## Overview

This document outlines the design for implementing configurable TTL (Time To Live) for cache entries at both system default and per-domain levels. The implementation will replace the current hardcoded TTL values and provide flexible cache expiration management.

## Design Goals

1. **Replace hardcoded TTL**: Remove the current hardcoded 60-second TTL in the request handler
2. **System-wide default**: Implement configurable `default_ttl_seconds` with 1-day default
3. **Per-domain TTL**: Allow domain-specific TTL configuration
4. **Backward compatibility**: Ensure existing configurations continue to work
5. **Performance**: Minimal overhead for TTL determination during request processing

## Current State Analysis

### Issues Identified
- **Hardcoded TTL**: Handler sets `ttl_seconds: 60` regardless of configuration
- **Unused configuration**: `default_ttl_days` exists in config but isn't used
- **Inconsistent units**: Configuration uses days but cache engine expects seconds
- **No domain-specific TTL**: All domains use the same TTL value

### Current Flow
```
Request → Handler → Cache Engine.set(response with hardcoded 60s TTL)
```

## Proposed Design

### 1. Configuration Schema Changes

#### 1.1 Default Configuration Updates

**File**: `reference_api_buddy/core/config.py`

Replace `default_ttl_days` with `default_ttl_seconds`:

```python
DEFAULT_CONFIG = {
    "cache": {
        "database_path": ":memory:",
        "max_cache_response_size": 10485760,
        "default_ttl_seconds": 86400,  # 1 day = 24 * 3600 seconds
    },
    # ... other config sections
}
```

#### 1.2 Domain-Specific TTL Configuration

Extend `domain_mappings` to support TTL configuration:

```python
"domain_mappings": {
    "example": {
        "upstream": "https://api.example.com",
        "ttl_seconds": 3600  # Optional: 1 hour for this domain
    },
    "slow_api": {
        "upstream": "https://slow.api.com",
        "ttl_seconds": 86400  # Optional: 1 day for slow APIs
    },
    "fast_changing": {
        "upstream": "https://fast.api.com",
        "ttl_seconds": 300  # Optional: 5 minutes for fast-changing data
    }
}
```

#### 1.3 Configuration Validation

Update `ConfigurationValidator` to validate new TTL fields:

```python
def validate_config(config: dict) -> Tuple[bool, List[str]]:
    # ... existing validation ...

    # Validate cache TTL
    cache = config.get("cache", {})
    default_ttl = cache.get("default_ttl_seconds")
    if default_ttl is not None and (not isinstance(default_ttl, int) or default_ttl <= 0):
        errors.append("cache.default_ttl_seconds must be a positive integer.")

    # Validate domain-specific TTL
    domain_mappings = config.get("domain_mappings", {})
    for domain_key, mapping in domain_mappings.items():
        if isinstance(mapping, dict):
            ttl = mapping.get("ttl_seconds")
            if ttl is not None and (not isinstance(ttl, int) or ttl <= 0):
                errors.append(f"domain_mappings.{domain_key}.ttl_seconds must be a positive integer.")
```

### 2. TTL Resolution Service

#### 2.1 TTL Manager Class

Create a new utility class to handle TTL resolution:

**File**: `reference_api_buddy/utils/ttl_manager.py`

```python
"""TTL management utilities for cache configuration."""

from typing import Optional


class TTLManager:
    """Manages TTL resolution for cache entries based on domain configuration."""

    def __init__(self, config: dict):
        """Initialize TTL manager with configuration.

        Args:
            config: Full proxy configuration dictionary
        """
        self.config = config
        self.default_ttl = config.get("cache", {}).get("default_ttl_seconds", 86400)
        self.domain_mappings = config.get("domain_mappings", {})

    def get_ttl_for_domain(self, domain_key: str) -> int:
        """Get TTL value for a specific domain.

        Args:
            domain_key: The domain key from domain_mappings

        Returns:
            TTL in seconds - domain-specific if configured, otherwise default
        """
        if domain_key in self.domain_mappings:
            domain_config = self.domain_mappings[domain_key]
            if isinstance(domain_config, dict):
                return domain_config.get("ttl_seconds", self.default_ttl)

        return self.default_ttl

    def get_default_ttl(self) -> int:
        """Get the system default TTL value.

        Returns:
            Default TTL in seconds
        """
        return self.default_ttl
```

### 3. Cache Engine Modifications

#### 3.1 Enhanced Set Method

Update the cache engine to accept domain information:

**File**: `reference_api_buddy/cache/engine.py`

```python
def set(self, cache_key: str, response: CachedResponse, domain_key: Optional[str] = None) -> bool:
    """Store a response in the cache with appropriate TTL.

    Args:
        cache_key: The cache key
        response: Response object to cache
        domain_key: Optional domain key for domain-specific TTL

    Returns:
        True if cached successfully, False otherwise
    """
    # If no TTL is set in response, determine it based on domain/default
    if hasattr(self, '_ttl_manager') and response.ttl_seconds is None:
        if domain_key:
            response.ttl_seconds = self._ttl_manager.get_ttl_for_domain(domain_key)
        else:
            response.ttl_seconds = self._ttl_manager.get_default_ttl()

    # ... rest of existing set method logic ...
```

#### 3.2 TTL Manager Integration

Add TTL manager to cache engine initialization:

```python
def __init__(
    self,
    db_manager: DatabaseManager,
    config: dict = None,
    max_response_size: int = 10485760,
    compression_threshold: int = 1024,
    max_cache_entries: int = 1000,
) -> None:
    """Initialize cache engine with database manager and configuration.

    Args:
        db_manager: Database manager for persistent storage
        config: Full configuration dictionary for TTL management
        max_response_size: Maximum response size to cache (bytes)
        compression_threshold: Minimum size for compression (bytes)
        max_cache_entries: Maximum number of cache entries
    """
    # ... existing initialization ...

    # Initialize TTL manager if config is provided
    if config:
        from reference_api_buddy.utils.ttl_manager import TTLManager
        self._ttl_manager = TTLManager(config)
    else:
        self._ttl_manager = None
```

### 4. Request Handler Updates

#### 4.1 TTL Integration in Handler

**File**: `reference_api_buddy/core/handler.py`

Update the response caching logic to use proper TTL:

```python
def _handle_request(self, method: str):
    # ... existing request handling logic ...

    # After forwarding request and getting response
    if (method in ("GET", "POST") and
        hasattr(self.proxy, "cache_engine") and
        self.proxy.cache_engine is not None):

        # Create response object with proper TTL
        resp_obj = CachedResponse(
            data=response_data,
            headers=headers,
            status_code=status_code,
            created_at=None,  # Will be set by database
            ttl_seconds=None,  # Will be determined by TTL manager
            access_count=0,
            last_accessed=None
        )

        # Cache with domain information for TTL resolution
        self.proxy.cache_engine.set(cache_key, resp_obj, domain_key=matched_domain_key)
```

### 5. Proxy Integration

#### 5.1 Proxy Constructor Updates

**File**: `reference_api_buddy/core/proxy.py`

Ensure cache engine receives configuration:

```python
def __init__(self, config: dict):
    # ... existing initialization ...

    # Initialize cache engine with full config for TTL management
    if cache_config.get("database_path") != "disabled":
        self.cache_engine = CacheEngine(
            self.db_manager,
            config=config,  # Pass full config for TTL manager
            max_response_size=cache_config.get("max_cache_response_size", 10485760),
            # ... other parameters
        )
```

### 6. CLI and Default Configuration Updates

#### 6.1 CLI Default Configuration

**File**: `reference_api_buddy/cli.py`

Update default configuration creation:

```python
def create_default_config() -> Dict[str, Any]:
    """Create a default configuration."""
    import os

    db_path = os.environ.get("API_BUDDY_DB_PATH", "api_buddy_cache.db")
    log_level = os.environ.get("API_BUDDY_LOG_LEVEL", "INFO")

    return {
        "server": {"host": "127.0.0.1", "port": 8080},
        "security": {"require_secure_key": True},
        "cache": {
            "database_path": db_path,
            "default_ttl_seconds": 86400  # 1 day in seconds
        },
        "throttling": {"default_requests_per_hour": 1000},
        "domain_mappings": {
            "example": {
                "upstream": "https://api.example.com",
                "ttl_seconds": 3600  # Example: 1 hour for demo
            }
        },
        "logging": {"level": log_level},
    }
```

### 7. Testing Strategy

#### 8.1 Unit Tests

##### 8.1.1 TTL Manager Tests

**File**: `tests/unit_tests/test_ttl_manager.py`

```python
import pytest
from reference_api_buddy.utils.ttl_manager import TTLManager


class TestTTLManager:
    """Test TTL Manager functionality."""

    def test_default_ttl_resolution(self):
        """Test default TTL is used when no domain-specific TTL is configured."""
        config = {
            "cache": {"default_ttl_seconds": 7200},
            "domain_mappings": {
                "example": {"upstream": "https://api.example.com"}
            }
        }
        ttl_manager = TTLManager(config)

        assert ttl_manager.get_ttl_for_domain("example") == 7200
        assert ttl_manager.get_default_ttl() == 7200

    def test_domain_specific_ttl_resolution(self):
        """Test domain-specific TTL overrides default."""
        config = {
            "cache": {"default_ttl_seconds": 86400},
            "domain_mappings": {
                "fast_api": {
                    "upstream": "https://fast.api.com",
                    "ttl_seconds": 300
                },
                "slow_api": {
                    "upstream": "https://slow.api.com",
                    "ttl_seconds": 7200
                }
            }
        }
        ttl_manager = TTLManager(config)

        assert ttl_manager.get_ttl_for_domain("fast_api") == 300
        assert ttl_manager.get_ttl_for_domain("slow_api") == 7200
        assert ttl_manager.get_default_ttl() == 86400

    def test_fallback_to_default_for_unmapped_domain(self):
        """Test fallback to default TTL for domains without specific configuration."""
        config = {
            "cache": {"default_ttl_seconds": 3600},
            "domain_mappings": {}
        }
        ttl_manager = TTLManager(config)

        assert ttl_manager.get_ttl_for_domain("unmapped_domain") == 3600
        assert ttl_manager.get_ttl_for_domain("another_unmapped") == 3600

    def test_missing_cache_config_uses_default(self):
        """Test TTL manager works with missing cache configuration."""
        config = {"domain_mappings": {}}
        ttl_manager = TTLManager(config)

        assert ttl_manager.get_default_ttl() == 86400  # Default 1 day
        assert ttl_manager.get_ttl_for_domain("any_domain") == 86400

    def test_invalid_domain_mapping_format(self):
        """Test TTL manager handles invalid domain mapping formats gracefully."""
        config = {
            "cache": {"default_ttl_seconds": 1800},
            "domain_mappings": {
                "string_mapping": "https://api.example.com",  # Invalid: should be dict
                "valid_mapping": {
                    "upstream": "https://valid.api.com",
                    "ttl_seconds": 900
                }
            }
        }
        ttl_manager = TTLManager(config)

        assert ttl_manager.get_ttl_for_domain("string_mapping") == 1800  # Falls back to default
        assert ttl_manager.get_ttl_for_domain("valid_mapping") == 900
```

##### 8.1.2 Cache Engine TTL Tests

**File**: `tests/unit_tests/test_cache_engine_ttl.py`

```python
import pytest
import time
from unittest.mock import Mock, patch
from reference_api_buddy.cache.engine import CacheEngine
from reference_api_buddy.database.manager import DatabaseManager
from reference_api_buddy.database.models import CachedResponse


class TestCacheEngineTTL:
    """Test cache engine TTL functionality."""

    @pytest.fixture
    def config_with_ttl(self):
        return {
            "cache": {"default_ttl_seconds": 3600},
            "domain_mappings": {
                "short_ttl": {
                    "upstream": "https://short.api.com",
                    "ttl_seconds": 300
                },
                "long_ttl": {
                    "upstream": "https://long.api.com",
                    "ttl_seconds": 7200
                }
            }
        }

    @pytest.fixture
    def cache_engine_with_config(self, config_with_ttl):
        db_manager = DatabaseManager(":memory:")
        return CacheEngine(db_manager, config=config_with_ttl)

    @pytest.fixture
    def sample_response_no_ttl(self):
        return CachedResponse(
            data=b"response-data",
            headers={"Content-Type": "application/json"},
            status_code=200,
            created_at=None,
            ttl_seconds=None,  # No TTL set, should be determined by config
            access_count=0,
            last_accessed=None,
        )

    def test_cache_engine_uses_domain_ttl(self, cache_engine_with_config, sample_response_no_ttl):
        """Test cache engine uses domain-specific TTL when provided."""
        cache_key = "test_key"

        # Test short TTL domain
        assert cache_engine_with_config.set(cache_key + "_short", sample_response_no_ttl, domain_key="short_ttl")
        cached_short = cache_engine_with_config.get(cache_key + "_short")
        assert cached_short.ttl_seconds == 300

        # Test long TTL domain
        assert cache_engine_with_config.set(cache_key + "_long", sample_response_no_ttl, domain_key="long_ttl")
        cached_long = cache_engine_with_config.get(cache_key + "_long")
        assert cached_long.ttl_seconds == 7200

    def test_cache_engine_uses_default_ttl(self, cache_engine_with_config, sample_response_no_ttl):
        """Test cache engine uses default TTL when no domain specified."""
        cache_key = "test_key_default"

        assert cache_engine_with_config.set(cache_key, sample_response_no_ttl)
        cached = cache_engine_with_config.get(cache_key)
        assert cached.ttl_seconds == 3600  # Default from config

    def test_cache_engine_respects_explicit_ttl(self, cache_engine_with_config):
        """Test cache engine respects explicitly set TTL in response object."""
        explicit_response = CachedResponse(
            data=b"response-data",
            headers={"Content-Type": "application/json"},
            status_code=200,
            created_at=None,
            ttl_seconds=1234,  # Explicit TTL set
            access_count=0,
            last_accessed=None,
        )
        cache_key = "test_key_explicit"

        assert cache_engine_with_config.set(cache_key, explicit_response, domain_key="short_ttl")
        cached = cache_engine_with_config.get(cache_key)
        assert cached.ttl_seconds == 1234  # Should keep explicit TTL, not use domain config

    def test_cache_engine_without_config(self):
        """Test cache engine works without TTL configuration."""
        db_manager = DatabaseManager(":memory:")
        cache_engine = CacheEngine(db_manager)  # No config provided

        response = CachedResponse(
            data=b"response-data",
            headers={"Content-Type": "application/json"},
            status_code=200,
            created_at=None,
            ttl_seconds=None,
            access_count=0,
            last_accessed=None,
        )

        # Should not crash, but TTL won't be set automatically
        cache_key = "test_key"
        # This test verifies the code doesn't crash when no config is provided
        try:
            cache_engine.set(cache_key, response, domain_key="any_domain")
        except AttributeError:
            pytest.fail("Cache engine should handle missing config gracefully")

    def test_ttl_expiration_with_domain_config(self, cache_engine_with_config, monkeypatch):
        """Test that entries expire according to domain-specific TTL."""
        response = CachedResponse(
            data=b"response-data",
            headers={"Content-Type": "application/json"},
            status_code=200,
            created_at="2025-08-21 12:00:00",
            ttl_seconds=None,
            access_count=0,
            last_accessed=None,
        )
        cache_key = "expiry_test"

        # Set with short TTL domain (300 seconds)
        assert cache_engine_with_config.set(cache_key, response, domain_key="short_ttl")

        # Mock time to be just before expiry
        mock_time = time.mktime(time.strptime("2025-08-21 12:04:59", "%Y-%m-%d %H:%M:%S"))
        monkeypatch.setattr("time.time", lambda: mock_time)

        # Should still be cached
        cached = cache_engine_with_config.get(cache_key)
        assert cached is not None

        # Mock time to be after expiry (300 seconds = 5 minutes)
        mock_time = time.mktime(time.strptime("2025-08-21 12:05:01", "%Y-%m-%d %H:%M:%S"))
        monkeypatch.setattr("time.time", lambda: mock_time)

        # Should be expired
        cached = cache_engine_with_config.get(cache_key)
        assert cached is None
```

##### 8.1.3 Configuration Tests

**File**: `tests/unit_tests/test_config_ttl.py`

```python
import pytest
from reference_api_buddy.core.config import ConfigurationValidator


class TestTTLConfiguration:
    """Test TTL configuration validation and migration."""

    def test_valid_ttl_configuration(self):
        """Test validation of valid TTL configuration."""
        config = {
            "cache": {"default_ttl_seconds": 3600},
            "domain_mappings": {
                "api1": {
                    "upstream": "https://api1.com",
                    "ttl_seconds": 1800
                }
            }
        }

        valid, errors = ConfigurationValidator.validate_config(config)
        assert valid
        assert len(errors) == 0

    def test_invalid_ttl_configuration(self):
        """Test validation of invalid TTL configuration."""
        config = {
            "cache": {"default_ttl_seconds": -100},  # Invalid: negative
            "domain_mappings": {
                "api1": {
                    "upstream": "https://api1.com",
                    "ttl_seconds": "not_a_number"  # Invalid: not integer
                }
            }
        }

        valid, errors = ConfigurationValidator.validate_config(config)
        assert not valid
        assert any("default_ttl_seconds must be a positive integer" in error for error in errors)
        assert any("ttl_seconds must be a positive integer" in error for error in errors)
```

#### 8.2 Integration Tests

##### 8.2.1 End-to-End TTL Tests

**File**: `tests/integration_tests/test_ttl_integration.py`

```python
import json
import tempfile
import time
from pathlib import Path
import pytest
import requests
from reference_api_buddy.core.proxy import CachingProxy


class TestTTLIntegration:
    """Integration tests for TTL functionality."""

    @pytest.fixture
    def ttl_config(self):
        return {
            "server": {"host": "127.0.0.1", "port": 0},  # Random port
            "security": {"require_secure_key": False},
            "cache": {
                "database_path": ":memory:",
                "default_ttl_seconds": 1800  # 30 minutes
            },
            "domain_mappings": {
                "httpbin": {
                    "upstream": "https://httpbin.org",
                    "ttl_seconds": 60  # 1 minute for testing
                },
                "slow_api": {
                    "upstream": "https://httpbin.org",
                    "ttl_seconds": 3600  # 1 hour
                }
            },
            "logging": {"level": "INFO"}
        }

    @pytest.fixture
    def proxy_with_ttl(self, ttl_config):
        proxy = CachingProxy(ttl_config)
        proxy.start(blocking=False)
        yield proxy
        proxy.stop()

    def test_end_to_end_domain_ttl(self, proxy_with_ttl):
        """Test complete flow from request to cache with domain-specific TTL."""
        port = proxy_with_ttl.server.server_port
        base_url = f"http://127.0.0.1:{port}"

        # Make request to domain with short TTL
        response1 = requests.get(f"{base_url}/httpbin/json", timeout=10)
        assert response1.status_code == 200

        # Verify cache entry was created with domain-specific TTL
        cache_performance = proxy_with_ttl.cache_engine.get_cache_performance()
        assert cache_performance["total_entries"] == 1

        # Get the cache key and verify TTL
        cache_key = proxy_with_ttl.cache_engine.generate_cache_key("GET", "/httpbin/json")
        cached_entry = proxy_with_ttl.cache_engine.get(cache_key)
        assert cached_entry is not None
        assert cached_entry.ttl_seconds == 60  # Should use domain-specific TTL

    def test_ttl_configuration_via_config_file(self):
        """Test TTL configuration loading from JSON config file."""
        config = {
            "server": {"host": "127.0.0.1", "port": 0},
            "security": {"require_secure_key": False},
            "cache": {
                "database_path": ":memory:",
                "default_ttl_seconds": 2400
            },
            "domain_mappings": {
                "test_domain": {
                    "upstream": "https://httpbin.org",
                    "ttl_seconds": 900
                }
            }
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(config, f)
            config_path = f.name

        try:
            # Load config from file
            from reference_api_buddy.cli import load_config
            loaded_config = load_config(Path(config_path))

            # Create proxy with loaded config
            proxy = CachingProxy(loaded_config)

            # Verify TTL configuration was loaded correctly
            assert proxy.cache_engine._ttl_manager.get_default_ttl() == 2400
            assert proxy.cache_engine._ttl_manager.get_ttl_for_domain("test_domain") == 900

        finally:
            Path(config_path).unlink()  # Clean up temp file

    def test_cache_expiration_with_different_ttls(self, proxy_with_ttl, monkeypatch):
        """Test that different domains expire at different times."""
        port = proxy_with_ttl.server.server_port
        base_url = f"http://127.0.0.1:{port}"

        # Make requests to domains with different TTLs
        response1 = requests.get(f"{base_url}/httpbin/uuid", timeout=10)  # 60s TTL
        response2 = requests.get(f"{base_url}/slow_api/uuid", timeout=10)  # 3600s TTL

        assert response1.status_code == 200
        assert response2.status_code == 200

        # Verify both are cached
        cache_performance = proxy_with_ttl.cache_engine.get_cache_performance()
        assert cache_performance["total_entries"] == 2

        # Mock time to be 90 seconds later (past httpbin TTL, within slow_api TTL)
        original_time = time.time()
        monkeypatch.setattr("time.time", lambda: original_time + 90)

        # Force cleanup of expired entries
        proxy_with_ttl.cache_engine._cleanup_expired_entries()

        # Verify httpbin entry expired but slow_api entry remains
        cache_performance = proxy_with_ttl.cache_engine.get_cache_performance()
        assert cache_performance["total_entries"] == 1
        assert cache_performance["expired_entries"] >= 1
```

#### 8.3 Performance Tests

##### 8.3.1 TTL Performance Impact

**File**: `tests/performance_tests/test_ttl_performance.py`

```python
import time
import pytest
from reference_api_buddy.cache.engine import CacheEngine
from reference_api_buddy.database.manager import DatabaseManager
from reference_api_buddy.database.models import CachedResponse


class TestTTLPerformance:
    """Performance tests for TTL functionality."""

    @pytest.fixture
    def large_domain_config(self):
        """Configuration with many domains for performance testing."""
        config = {
            "cache": {"default_ttl_seconds": 3600},
            "domain_mappings": {}
        }

        # Create 1000 domain mappings with different TTLs
        for i in range(1000):
            config["domain_mappings"][f"domain_{i}"] = {
                "upstream": f"https://api{i}.example.com",
                "ttl_seconds": 300 + (i % 3600)  # Vary TTL from 300 to 3900 seconds
            }

        return config

    def test_ttl_resolution_performance(self, large_domain_config):
        """Test that TTL resolution remains fast with many domains."""
        db_manager = DatabaseManager(":memory:")
        cache_engine = CacheEngine(db_manager, config=large_domain_config)

        response = CachedResponse(
            data=b"test-data",
            headers={"Content-Type": "application/json"},
            status_code=200,
            created_at=None,
            ttl_seconds=None,
            access_count=0,
            last_accessed=None,
        )

        # Measure time for TTL resolution across many domains
        start_time = time.time()

        for i in range(100):  # Test 100 cache operations
            domain_key = f"domain_{i % 1000}"
            cache_key = f"test_key_{i}"
            cache_engine.set(cache_key, response, domain_key=domain_key)

        end_time = time.time()
        elapsed = end_time - start_time

        # Should complete 100 operations in less than 1 second
        assert elapsed < 1.0, f"TTL resolution took too long: {elapsed:.3f}s"

        # Verify TTLs were set correctly
        for i in range(10):  # Check a sample
            cache_key = f"test_key_{i}"
            cached = cache_engine.get(cache_key)
            expected_ttl = 300 + (i % 3600)
            assert cached.ttl_seconds == expected_ttl

    def test_cache_expiration_cleanup_performance(self, large_domain_config):
        """Test performance of expired entry cleanup with many entries."""
        db_manager = DatabaseManager(":memory:")
        cache_engine = CacheEngine(db_manager, config=large_domain_config, max_cache_entries=10000)

        # Create many cache entries with short TTL
        response = CachedResponse(
            data=b"test-data",
            headers={"Content-Type": "application/json"},
            status_code=200,
            created_at="2025-08-21 12:00:00",  # Set in the past
            ttl_seconds=1,  # Very short TTL for immediate expiration
            access_count=0,
            last_accessed=None,
        )

        # Insert 1000 entries
        for i in range(1000):
            cache_key = f"expired_key_{i}"
            cache_engine.set(cache_key, response)

        # Measure cleanup performance
        start_time = time.time()
        cache_engine._cleanup_expired_entries()
        end_time = time.time()

        elapsed = end_time - start_time

        # Cleanup should complete quickly even with many expired entries
        assert elapsed < 2.0, f"Cleanup took too long: {elapsed:.3f}s"

        # Verify entries were cleaned up
        cache_performance = cache_engine.get_cache_performance()
        assert cache_performance["total_entries"] == 0
        assert cache_performance["expired_entries"] >= 1000
```

#### 8.4 Edge Case Tests

##### 8.4.1 TTL Edge Cases

**File**: `tests/unit_tests/test_ttl_edge_cases.py`

```python
import pytest
from reference_api_buddy.utils.ttl_manager import TTLManager
from reference_api_buddy.cache.engine import CacheEngine
from reference_api_buddy.database.manager import DatabaseManager
from reference_api_buddy.database.models import CachedResponse


class TestTTLEdgeCases:
    """Test edge cases for TTL functionality."""

    def test_zero_ttl_handling(self):
        """Test handling of zero TTL (immediate expiration)."""
        config = {
            "cache": {"default_ttl_seconds": 0},
            "domain_mappings": {
                "immediate_expire": {
                    "upstream": "https://api.example.com",
                    "ttl_seconds": 0
                }
            }
        }

        # Should handle zero TTL without crashing (though validation should catch this)
        ttl_manager = TTLManager(config)
        assert ttl_manager.get_default_ttl() == 0
        assert ttl_manager.get_ttl_for_domain("immediate_expire") == 0

    def test_very_large_ttl_handling(self):
        """Test handling of very large TTL values."""
        large_ttl = 31536000000  # ~1000 years in seconds
        config = {
            "cache": {"default_ttl_seconds": large_ttl},
            "domain_mappings": {
                "long_cache": {
                    "upstream": "https://api.example.com",
                    "ttl_seconds": large_ttl
                }
            }
        }

        ttl_manager = TTLManager(config)
        assert ttl_manager.get_default_ttl() == large_ttl
        assert ttl_manager.get_ttl_for_domain("long_cache") == large_ttl

    def test_missing_upstream_with_ttl(self):
        """Test domain config with TTL but missing upstream."""
        config = {
            "cache": {"default_ttl_seconds": 3600},
            "domain_mappings": {
                "incomplete_domain": {
                    "ttl_seconds": 1800
                    # Missing "upstream" field
                }
            }
        }

        # TTL manager should still work even if upstream is missing
        ttl_manager = TTLManager(config)
        assert ttl_manager.get_ttl_for_domain("incomplete_domain") == 1800

    def test_nested_domain_keys(self):
        """Test TTL resolution with complex domain key names."""
        config = {
            "cache": {"default_ttl_seconds": 3600},
            "domain_mappings": {
                "api.v1.subdomain": {
                    "upstream": "https://api.v1.subdomain.example.com",
                    "ttl_seconds": 900
                },
                "api-with-dashes": {
                    "upstream": "https://api-with-dashes.example.com",
                    "ttl_seconds": 1200
                },
                "api_with_underscores": {
                    "upstream": "https://api_with_underscores.example.com",
                    "ttl_seconds": 1500
                }
            }
        }

        ttl_manager = TTLManager(config)
        assert ttl_manager.get_ttl_for_domain("api.v1.subdomain") == 900
        assert ttl_manager.get_ttl_for_domain("api-with-dashes") == 1200
        assert ttl_manager.get_ttl_for_domain("api_with_underscores") == 1500

    def test_cache_engine_ttl_with_malformed_response(self):
        """Test cache engine handles malformed response objects gracefully."""
        config = {"cache": {"default_ttl_seconds": 3600}}
        db_manager = DatabaseManager(":memory:")
        cache_engine = CacheEngine(db_manager, config=config)

        # Response with missing required fields
        malformed_response = type('Response', (), {
            'data': b'test',
            'headers': {},
            'status_code': 200,
            # Missing created_at, ttl_seconds, access_count, last_accessed
        })()

        cache_key = "malformed_test"

        # Should handle gracefully without crashing
        try:
            result = cache_engine.set(cache_key, malformed_response)
            # Might succeed or fail depending on implementation, but shouldn't crash
        except (AttributeError, TypeError):
            # Expected if response object is malformed
            pass

    def test_concurrent_ttl_resolution(self):
        """Test TTL resolution under concurrent access."""
        import threading
        import time

        config = {
            "cache": {"default_ttl_seconds": 3600},
            "domain_mappings": {
                f"domain_{i}": {
                    "upstream": f"https://api{i}.example.com",
                    "ttl_seconds": 300 + i
                }
                for i in range(100)
            }
        }

        ttl_manager = TTLManager(config)
        results = {}
        errors = []

        def resolve_ttl(domain_key):
            try:
                ttl = ttl_manager.get_ttl_for_domain(domain_key)
                results[domain_key] = ttl
            except Exception as e:
                errors.append(e)

        # Start many threads resolving TTL simultaneously
        threads = []
        for i in range(50):
            domain_key = f"domain_{i}"
            thread = threading.Thread(target=resolve_ttl, args=(domain_key,))
            threads.append(thread)
            thread.start()

        # Wait for all threads to complete
        for thread in threads:
            thread.join()

        # Verify no errors occurred and results are correct
        assert len(errors) == 0, f"Errors during concurrent access: {errors}"
        assert len(results) == 50

        for i in range(50):
            domain_key = f"domain_{i}"
            expected_ttl = 300 + i
            assert results[domain_key] == expected_ttl
```

#### 8.5 Test Coverage Requirements

##### 8.5.1 Coverage Metrics

- **Overall TTL functionality**: Minimum 95% line coverage
- **TTL Manager**: 100% line coverage (critical component)
- **Cache Engine TTL integration**: 95% line coverage
- **Configuration validation**: 100% line coverage for TTL-related validation
- **Edge cases**: Cover all identified edge cases and error conditions

##### 8.5.2 Test Execution Strategy

```bash
# Run all TTL-related tests
pytest tests/unit_tests/test_ttl_* tests/integration_tests/test_ttl_* -v

# Run with coverage reporting
pytest tests/unit_tests/test_ttl_* tests/integration_tests/test_ttl_* \
    --cov=reference_api_buddy.utils.ttl_manager \
    --cov=reference_api_buddy.cache.engine \
    --cov=reference_api_buddy.core.config \
    --cov-report=html \
    --cov-report=term-missing

# Performance tests (separate from regular test suite)
pytest tests/performance_tests/test_ttl_performance.py -v --tb=short

# Edge case tests
pytest tests/unit_tests/test_ttl_edge_cases.py -v
```

##### 8.5.3 Continuous Integration

```yaml
# Add to CI pipeline
- name: Run TTL Tests
  run: |
    pytest tests/unit_tests/test_ttl_* tests/integration_tests/test_ttl_* \
      --cov=reference_api_buddy.utils.ttl_manager \
      --cov=reference_api_buddy.cache.engine \
      --cov-fail-under=95 \
      --junitxml=test-results/ttl-tests.xml

- name: Performance Tests
  run: |
    pytest tests/performance_tests/test_ttl_performance.py \
      --benchmark-only \
      --benchmark-json=test-results/ttl-benchmarks.json
```

### 9. Configuration Examples

#### 9.1 Simple Configuration

```json
{
  "cache": {
    "default_ttl_seconds": 7200
  },
  "domain_mappings": {
    "api1": {
      "upstream": "https://api1.example.com"
    }
  }
}
```

#### 9.2 Advanced Configuration

```json
{
  "cache": {
    "default_ttl_seconds": 86400
  },
  "domain_mappings": {
    "weather": {
      "upstream": "https://api.weather.com",
      "ttl_seconds": 1800
    },
    "user_data": {
      "upstream": "https://api.users.com",
      "ttl_seconds": 300
    },
    "static_content": {
      "upstream": "https://static.example.com",
      "ttl_seconds": 604800
    }
  }
}
```
